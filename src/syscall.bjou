# syscall.bjou
#
# Machine and User mode system call interface.

module syscall

using import "asm.bjou"
using import "console.bjou"
using import "sched.bjou"
using import "util.bjou"
using import "PCB.bjou"
using import "abort.bjou"

const EXIT    := 1u32
const WRITE   := 2u32
const READ    := 3u32
const ALLOC   := 4u32
const FREE    := 5u32
const BARRIER := 6u32
const SPAWN   := 6u32
const WAITPID := 7u32
const KILL    := 8u32
const NPROC   := 9u32
const PROCS   := 10u32
const SLEEP   := 11u32
const MYPID   := 12u32

const UMODE   := 0u32
const MMODE   := 3u32

type process_info {
    pid      : i16
    vruntime : u32
    name     : char*
    waitpid  : i16
    sleep    : i16
}

proc msyscall(code : u32) {
    if code == UMODE {
        asm$umode_switch()
    } else if code == MMODE {
        asm$mmode_switch()
    } else {
        writeln("Unknown Machine Mode ECALL CODE")
    }
}

proc syscall(code : u32, arg0 : u32, arg1 : u32, arg2 : u32, arg3 : u32, arg4 : u32, arg5 : u32) : u32 {
    result := asm$ecall(code, arg0, arg1, arg2, arg3, arg4, arg5)
    if code == EXIT
        while true asm$wfi()
    else if code == WAITPID
         or code == SLEEP
        asm$wfi()
    return result
}
proc alloc(n_bytes : u32) : void* { return syscall(ALLOC, n_bytes, 0, 0, 0, 0, 0) as void* }
proc free(ptr : void*) { syscall(FREE, ptr as u32, 0, 0, 0, 0, 0) as void* }
proc exit() : u32 { return syscall(EXIT, 0, 0, 0, 0, 0, 0) }
proc spawn(stack_size : u32, ip : u32, QM : u32, data : void*, data_len : u32, name : char*) : u32 {
    return syscall(SPAWN, stack_size, ip, QM, data as u32, data_len, ptr_to_u32(name))
}
proc waitpid(pid : i32) : u32 { return syscall(WAITPID, pid as u32, 0, 0, 0, 0, 0) }
proc kill(pid : i32) : u32 { return syscall(KILL, pid as u32, 0, 0, 0, 0, 0) }
proc nproc() : u32 { return syscall(NPROC, 0, 0, 0, 0, 0, 0) }
proc procs(ptr : process_info**) : u32 { return syscall(PROCS, ptr_to_u32(ptr), 0, 0, 0, 0, 0) }
proc sleep(secs : u32) { syscall(SLEEP, secs, 0, 0, 0, 0, 0) }
proc mypid() : i16 { return syscall(MYPID, 0, 0, 0, 0, 0, 0) as i16 }

proc handle_syscall(code : u32, arg0 : u32, arg1 : u32, arg2 : u32, arg3 : u32, arg4 : u32, arg5 : u32) : u32 {
    result := 0u32

    if code == EXIT {
        result = handle_exit()
    } else if code == ALLOC {
        result = handle_alloc(arg0)
    } else if code == FREE {
        result = handle_free(arg0)
    } else if code == SPAWN {
        result = handle_spawn(arg0, arg1, arg2, arg3, arg4, arg5)
    } else if code == WAITPID {
        result = handle_waitpid(arg0)
    } else if code == KILL {
        result = handle_kill(arg0)
    } else if code == NPROC {
        result = handle_nproc()
    } else if code == PROCS {
        result = handle_procs(arg0)
    } else if code == SLEEP {
        result = handle_sleep(arg0)
    } else if code == MYPID {
        result = handle_mypid()
    }

    return result
}

proc handle_exit() : u32 {
    if sched.current == (NULL as PCB*)
        return 1
    sched.current.kill = true
    return 0
}
proc handle_alloc(n_bytes : u32) : u32 {
    return kmalloc(n_bytes) as u32
}
proc handle_free(ptr : u32) : u32 {
    kfree(ptr as void*)
    return 0
}
proc handle_spawn(stack_size : u32, ip : u32, QM : u32, data : u32, data_len : u32, name : u32) : u32 {
    return sched.new_process(stack_size, ip, QM, data as void*, data_len, u32_to_ptr$char(name))
}
proc handle_waitpid(pid : u32) : u32 {
    if sched.current == (NULL as PCB*)
    or not sched.tree_has_pid(pid as i32) {
        return 1
    }
    sched.current.waitpid = pid as i32
    return 0
}
proc handle_kill(pid : u32) : u32 {
    pcb := sched.get_pcb(pid as i32)
    if pcb == (NULL as PCB*) {
        return 1
    }
    pcb.kill = true
    return 0
}
proc handle_nproc() : u32 {
    n_in_tree := sched.proc_tree.len
    if sched.current != (NULL as PCB*) {
        n_in_tree += 1
    }
    return n_in_tree
}
proc handle_procs(out : u32) : u32 {
    all_pcbs := sched.collect_all_procs()
    if all_pcbs == (NULL as PCB**)
        return 1
   
    n := 0
    for ptr := all_pcbs; @ptr != (NULL as PCB*); ptr += 1 {
        n += 1
    }
   
    proc_infos := kmalloc(n * sizeof process_info) as process_info*

    if proc_infos == (NULL as process_info*)
        abort("Could not allocate process_info array!")

    for i := 0; i < n; i += 1 {
        pcb  := getref(@all_pcbs[i])
        info := { process_info: }

        info.pid      = pcb.pid
        info.vruntime = pcb.vruntime
        info.name     = pcb.name
        info.waitpid  = pcb.waitpid
        info.sleep    = pcb.sleep

        proc_infos[i] = info
    }

    @u32_to_ptr$(process_info*)(out) = proc_infos

    return n
}
proc handle_sleep(secs : u32) : u32 {
    if sched.current == (NULL as PCB*)
        return 1
    sched.current.sleep = sched::QMS_PER_SEC * secs
    return 0
}
proc handle_mypid() : u32 {
    if sched.current == (NULL as PCB*)
        return -1
    return sched.current.pid
}
