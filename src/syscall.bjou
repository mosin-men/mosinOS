# syscall.bjou
#
# Machine and User mode system call interface.

module syscall

using import "asm.bjou"
using import "console.bjou"
using import "sched.bjou"
using import "util.bjou"
using import "PCB.bjou"

const EXIT    := 1u32
const WRITE   := 2u32
const READ    := 3u32
const ALLOC   := 4u32
const FREE    := 5u32
const BARRIER := 6u32
const SPAWN   := 6u32
const WAITPID := 7u32
const KILL    := 8u32
const NPROC   := 9u32
const PROCS   := 10u32
const SLEEP   := 11u32

const UMODE   := 0u32
const MMODE   := 3u32

proc msyscall(code : u32) {
    if code == UMODE {
        asm$umode_switch()
    } else if code == MMODE {
        asm$mmode_switch()
    } else {
        writeln("Unknown Machine Mode ECALL CODE")
    }
}

proc syscall(code : u32, arg0 : u32, arg1 : u32, arg2 : u32, arg3 : u32, arg4 : u32, arg5 : u32) : u32 {
    result := asm$ecall(code, arg0, arg1, arg2, arg3, arg4, arg5)
    if code == EXIT
        while true asm$wfi()
    else if code == WAITPID
         or code == SLEEP
        asm$wfi()
    return result
}
proc alloc(n_bytes : u32) : void* { return syscall(ALLOC, n_bytes, 0, 0, 0, 0, 0) as void* }
proc free(ptr : void*) { syscall(FREE, ptr as u32, 0, 0, 0, 0, 0) as void* }
proc exit() : u32 { return syscall(EXIT, 0, 0, 0, 0, 0, 0) }
proc spawn(stack_size : u32, ip : u32, QM : u32, data : void*, data_len : u32, name : char*) : u32 {
    return syscall(SPAWN, stack_size, ip, QM, data as u32, data_len, ptr_to_u32(name))
}
proc waitpid(pid : i32) : u32 { return syscall(WAITPID, pid as u32, 0, 0, 0, 0, 0) }
proc kill(pid : i32) : u32 { return syscall(KILL, pid as u32, 0, 0, 0, 0, 0) }
proc nproc() : u32 { return syscall(NPROC, 0, 0, 0, 0, 0, 0) }
proc procs() : u32 { return syscall(PROCS, 0, 0, 0, 0, 0, 0) }
proc sleep(secs : u32) { syscall(SLEEP, secs, 0, 0, 0, 0, 0) }

proc handle_syscall(code : u32, arg0 : u32, arg1 : u32, arg2 : u32, arg3 : u32, arg4 : u32, arg5 : u32) : u32 {
    result := 0u32

    if code == EXIT {
        result = handle_exit()
    } else if code == ALLOC {
        result = handle_alloc(arg0)
    } else if code == FREE {
        result = handle_free(arg0)
    } else if code == SPAWN {
        result = handle_spawn(arg0, arg1, arg2, arg3, arg4, arg5)
    } else if code == WAITPID {
        result = handle_waitpid(arg0)
    } else if code == KILL {
        result = handle_kill(arg0)
    } else if code == NPROC {
        result = handle_nproc()
    } else if code == PROCS {
        result = handle_procs()
    } else if code == SLEEP {
        result = handle_sleep(arg0)
    }

    return result
}

proc handle_exit() : u32 {
    if sched.current == (NULL as PCB*)
        return 1
    sched.current.kill = true
    return 0
}
proc handle_alloc(n_bytes : u32) : u32 {
    return kmalloc(n_bytes) as u32
}
proc handle_free(ptr : u32) : u32 {
    kfree(ptr as void*)
    return 0
}
proc handle_spawn(stack_size : u32, ip : u32, QM : u32, data : u32, data_len : u32, name : u32) : u32 {
    return sched.new_process(stack_size, ip, QM, data as void*, data_len, u32_to_ptr$char(name))
}
proc handle_waitpid(pid : u32) : u32 {
    if sched.current == (NULL as PCB*)
    or not sched.tree_has_pid(pid as i32) {
        return 1
    }
    sched.current.waitpid = pid as i32
    return 0
}
proc handle_kill(pid : u32) : u32 {
    pcb := sched.get_pcb(pid as i32)
    if pcb == (NULL as PCB*) {
        return 1
    }
    pcb.kill = true
    return 0
}
proc handle_nproc() : u32 {
    n_in_tree := sched.proc_tree.len
    if sched.current != (NULL as PCB*) {
        n_in_tree += 1
    }
    return n_in_tree
}
proc handle_procs() : u32 {
    return ptr_to_u32(sched.collect_all_procs())
}
proc handle_sleep(secs : u32) : u32 {
    if sched.current == (NULL as PCB*)
        return 1
    sched.current.sleep = sched::QMS_PER_SEC * secs
    return 0
}
