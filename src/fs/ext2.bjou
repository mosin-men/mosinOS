# fs/ext2.bjou
#
# file system

module ext2

using import "component_result.bjou"
using error
using none

ext2fs : ext2fs_t

externvar __fs_start : u32

type SuperBlock {
    inodes_cnt         : u32
    blocks_cnt         : u32
    r_blocks_cnt       : u32
    f_blocks_cnt       : u32
    f_inodes_cnt       : u32
    first_data_block   : u32
    log_block_size     : u32
    log_frag_size      : u32
    blocks_per_group   : u32
    frags_per_group    : u32
    inodes_per_group   : u32
    mtime              : u32
    wtime              : u32
    mnt_count          : u16
    max_mnt_count      : u16
    magic              : u16
    state              : u16
    errors             : u16
    minor_rev_level    : u16
    lastcheck          : u32
    check_interval     : u32
    creator_os         : u32
    rev_level          : u32
    def_resuid         : u16
    def_resgid         : u16
    first_inode        : u32
    inode_size         : u16
    block_group_number : u16
    feature_compat     : u32
    feature_incompat   : u32
    feature_ro_compat  : u32
}

type BlockGroupDescriptorTbl {
    block_bitmap    : u32
    inode_bitmap    : u32
    inode_table     : u32
    free_blocks_cnt : u16
    free_inodes_cnt : u16
    used_dirs_cnt   : u16
    pad             : u8[14]
}

type Inode {
    mode        : u16
    uid         : u16
    size        : u32
    atime       : u32
    ctime       : u32
    mtime       : u32
    dtime       : u32
    gid         : u16
    links_count : u16
    blocks      : u32
    flags       : u32
    osd1        : u32
    block       : u32[15]
    generation  : u32
    file_acl    : u32
    dir_acl     : u32
    faddr       : u32
    osd2        : u32[3]
}

type DirectoryEntry {
    inode     : u32
    rec_len   : u16
    name_len  : u8
    file_type : u8
    name      : char[256]
}

proc init() : component_result {
    sbr           := (&__fs_start) + 256
    sbp           := (sbr as void*) as SuperBlock*
    bs            := 1024u32 bshl sbp.log_block_size
    nblocks       := sbp.blocks_cnt
    nblock_groups := nblocks/sbp.blocks_per_group
    start_b       := << if bs == 1024u32 <- 2 else <- 1 >>

    ext2fs = { ext2fs_t:
        .sb               = sbp,
        .block_size       = bs,
        .blocks           = nblocks,
        .block_groups     = nblock_groups,
        .inodes_per_group = sbp.inodes_per_group,
        .inode_size       = sbp.inode_size as u32,
        .start_block      = start_b,
        .c_inode          = 2 # root inode
    }

    return { none: }
    # return { warning: .code = 1, .msg = "not using ext2 filesystem" }
}

type ext2fs_t {
    sb               : SuperBlock*
    block_size       : u32
    blocks           : u32
    block_groups     : u32
    inodes_per_group : u32
    inode_size       : u32
    start_block      : u32
    c_inode          : u32
}

# Get some information about the filesystem to show that it is, indeed
# a valid filesystem.
proc _get_fs_info() {
    writeln("Filesystem information: ")
    write("MAGIC NUMBER:     ")  writehexln(ext2fs.sb.magic)

    write("Creator:          ")
    if      ext2fs.sb.creator_os == 0    writeln("Linux")
    else if ext2fs.sb.creator_os == 1    writeln("GNU HURD")
    else if ext2fs.sb.creator_os == 2    writeln("MASIX")
    else if ext2fs.sb.creator_os == 3    writeln("FreeBSD")
    else if ext2fs.sb.creator_os == 4    writeln("Lites")
    else                                 writeln("?")

    write("inode count:      ")    writeln(ext2fs.sb.inodes_cnt as i32)
    write("Block count:      ")    writeln(ext2fs.sb.blocks_cnt as i32)
    write("Root block count: ")    writeln(ext2fs.sb.r_blocks_cnt as i32)
    write("Free blocks:      ")    writeln(ext2fs.sb.f_blocks_cnt as i32)
    write("Free inodes:      ")    writeln(ext2fs.sb.f_inodes_cnt as i32)
    write("Block size:       ")    write(ext2fs.block_size as i32)    writeln(" bytes")
    write("inode size:       ")    write(ext2fs.inode_size as i32)    writeln(" bytes")
    write("Blocks per group: ")    writeln(ext2fs.sb.blocks_per_group as i32)
    write("inodes per group: ")    writeln(ext2fs.inodes_per_group as i32)
    write("Block groups:     ")    writeln(ext2fs.block_groups as i32)
}

# Get a pointer to a data block from a block number. Saves some
# repeated code in subsequent functions.
proc _get_block(idx: u32) : void* {
    self := getref(ext2fs)

    fsb       := (&__fs_start) as void*
    block_off := (self.block_size * idx)
    blk       := fsb + block_off

    return blk
}

# Likewise, sometimes we need to get an inode from an index.
# This does that.
proc _get_inode(id: u32) : Inode* {
    self := getref(ext2fs)
    # Get inode and block index information based off fs structure
    # from superblock.
    inodes_per_block := self.block_size / self.inode_size
    bg               := (id - 1) / self.inodes_per_group
    idx              := (id - 1) % self.inodes_per_group
    blk_idx          := idx * self.inode_size / self.block_size

    # Now find the actual inode structure.
    fsb             := (&__fs_start) as void*
    bgds            := _get_block(self.start_block) as BlockGroupDescriptorTbl*
    bgd             := bgds + bg
    inode_block     := bgd.inode_table + blk_idx
    block_as_inodes := _get_block(inode_block) as Inode*
    inode_final     := block_as_inodes + (idx % inodes_per_block)

    return inode_final
}
