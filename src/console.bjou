# console.bjou

module console

import "defs.bjou"
import "uart.bjou"
import "static.bjou"
import "cstr.bjou"
using cstr

__con_ibuff : char[defs::CONSOLE_BUFF_SZ]
__con_obuff : char[defs::CONSOLE_BUFF_SZ]
__con       : console

# proc init() {
#     __con = console.create([ __con_ibuff, 0:|__con_ibuff| ], [ __con_obuff, 0:|__con_obuff| ])
# }

type console {
    ibuff   : static::Vec$char
    obuff   : static::Vec$char
    read_fn : <() : char>

    proc create(ibuff : char[], obuff : char[]) : console {
        ibuff' := static::Vec.create(ibuff)
        obuff' := static::Vec.create(obuff)

        c := { console: .ibuff = ibuff', .obuff = obuff' }
        c.echo_on()

        return c
    }

    proc echo_on(this) {
        this.read_fn = uart::read_echo
    }

    proc echo_off(this) {
        this.read_fn = uart::read
    }

    proc flush(this) {
        this.obuff.push('\0')
        uart::write_string(this.obuff.data)
        this.obuff.clear()
    }

    proc readchar(this) : char {
        c := '\0'
        while not c    { c = this.read_fn() }
        return c
    }

    proc readln(this, dst : char*) {
        c := '\0'
        while true {
            while not (c = this.read_fn()) {}
            
            if c == '\r' {
                this.ibuff.push('\n')
                break
            } else {
                this.ibuff.push(c)
            }

            if this.ibuff.len == this.ibuff.cap - 1
                break
        }
        this.ibuff.push('\0')
        cstrcpy(dst, this.ibuff.data)
        this.ibuff.clear()
    }

    proc write(this, c : char) {
        this.obuff.push(c)

        if c == '\n'
        or this.obuff.len == this.obuff.cap - 1
            this.flush()
    }

    proc write(this, s : char*) {
        while @s {
            this.obuff.push(@s)

            if @s == '\n'
            or this.obuff.len == this.obuff.cap - 1
                this.flush()

            s += 1
        }
    }
}

# proc readchar() : char {
#     return __con.readchar()
# }

# proc readln(dst : char*) {
#     __con.readln(dst)
# }

# proc write(c : char) {
#     __con.write(c)
# }

# proc write(s : char*) {
#     __con.write(s)
# }

# proc write(i : i32) {
#     buff : char[64]
#     itoa(i, buff)
#     __con.write(buff)
# }

# proc writeln() {
#     __con.write("\n")
# }

# proc writeln(i : i32) {
#     __con.write(i)
#     __con.write("\n")
# }

# proc writeln(s : char*) {
#     __con.write(s)
#     __con.write("\n")
# }

# proc flush() {
#     __con.flush()
# }
    
# proc echo_on() {
#     __con.echo_on()
# }

# proc echo_off() {
#     __con.echo_off()
# }
