# console.bjou
#
# Provides a higher-level interface to the UART device.
#
# The UART driver must be initialized and configured before
# console will work.
#
# console::init() should be called to initialize the singleton
# console's state.

module console

import "defs.bjou"
import "uart.bjou"
using import "cstr.bjou"
using import "util.bjou"
using import "component_result.bjou"
using none
using error 
using import "defs.bjou"
using import "ansi_escapes.bjou"

const NL_STR := "\r\n"

_con       : console

proc init() : component_result {
    _con = console.create()
    
    \static_if{ defs::ANSI_ESC
        return { none: } }
    \static_if{ not defs::ANSI_ESC
        return { warning: .code = 1, .msg = "missing support for ANSI escape codes -- functionality limited" } }
}

type console {
    read_fn : <() : char>

    proc create() : console {
        c := { console: }
        c.echo_on()

        return c
    }

    proc echo_on(this) {
        this.read_fn = uart::read_echo
    }

    proc echo_off(this) {
        this.read_fn = uart::read
    }

    proc readchar_nonblocking(this) : char    { return uart::read() }

    proc readchar(this) : char {
        c := '\0'
        while not c    { c = this.read_fn() }
        return c
    }

    proc readln(this, dst : char*) {
        ptr := dst

        save_rd_fn := this.read_fn
        this.echo_off()

        c := '\0'
        while true {
            while not (c = this.read_fn()) {}
           
            if c == '\r' {
                @dst = '\n'
                dst += 1
                write('\r')
                write('\n')
                break
            } else if c == 127 or c == 8 {
                if dst != ptr {
                    dst -= 1
                    @dst = '\0'
                    write(CURSOR_LEFT)
                    write(CLEAR_LINE)
                }
            } else {
                @dst = c
                dst += 1
                write(c)
            }
        }
        @dst = '\0'

        this.read_fn = save_rd_fn
    }

    proc write(this, c : char) {
        if c == '\n' {
            uart::write('\r')
        }
        uart::write(c)
    }

    proc write(this, s : char*) {
        while @s {
            this.write(@s)
            s += 1
        }
    }
}

proc readchar_nonblocking() : char {
    return _con.readchar_nonblocking()
}

proc readchar() : char {
    return _con.readchar()
}

proc readln(dst : char*) {
    _con.readln(dst)
}

proc write(c : char) {
    _con.write(c)
}

proc write(s : char*) {
    _con.write(s)
}

proc writepad(s : char*, l : u32) {
    len := cstrlen(s)
    _con.write(s)
    if len < l {
        for i := 0; i < l - len; i += 1 {
            _con.write(' ')
        }
    }
}

proc write(i : i32) {
    buff : char[64]
    itoa(i, buff)
    _con.write(buff)
}

proc writehex(u : u32) {
    buff : char[64]
    itoax(u, buff)
    _con.write("0x")
    _con.write(buff)
}

proc writehex(p : void*) {
    buff : char[64]
    itoax(ptr_to_u32(p), buff)
    _con.write("0x")
    _con.write(buff)
}

proc writebin(u : u32) {
    buff : char[33]
    itoab(u, buff)
    _con.write(buff)
}

proc writeln() {
    _con.write(NL_STR)
}

proc writeln(c : char) {
    _con.write(c)
    _con.write(NL_STR)
}

proc writeln(i : i32) {
    buff : char[64]
    itoa(i, buff)
    _con.write(buff)
    _con.write(NL_STR)
}

proc writehexln(u : u32) {
    buff : char[64]
    itoax(u, buff)
    _con.write("0x")
    _con.write(buff)
    _con.write(NL_STR)
}

proc writehexln(p : void*) {
    buff : char[64]
    itoax(ptr_to_u32(p), buff)
    _con.write("0x")
    _con.write(buff)
    _con.write(NL_STR)
}

proc writebinln(u : u32) {
    buff : char[33]
    itoab(u, buff)
    _con.write(buff)
    _con.write(NL_STR)
}

proc writeln(s : char*) {
    _con.write(s)
    _con.write(NL_STR)
}

proc echo_on() {
    _con.echo_on()
}

proc echo_off() {
    _con.echo_off()
}
