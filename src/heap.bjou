# heap.bjou
#
# The heap.
# This is how the kernel allocates memory to the heap.
# All process stacks are stored on this heap, as well
# as user heap allocations.
# This heap should consume the majority of RAM. The
# kernel's stack consumes 2K, and this heap should
# consume the remainder of the machine's 16K.
# Its mechanisms are simple: initialize by
# creating a 4-byte header that will serve as the first
# node in the freelist, and each time an allocation
# is made, iterate over the freelist and find the first
# free block of memory.
# Fails only when it cannot make the requested allocation.
# Frees memory by coallescing. It does this by
# first freeing up the block that was requested, and then
# looking one block up and down to see if they need to be
# merged. This prevents fragmentation.

module heap

using import "console.bjou"
using import "util.bjou"

const HEAP_NULL := (0x0 as void*) as u32*

externvar __heap_start : u32
externvar __heap_end   : u32
externvar __heap_size  : u32

# Masks to pack a freelist header into 32 bits.
# The layout looks like:

# uppppppp pppppppp tccccccc cccccccc
# 00000000 00000001 00001101 11011101

# t = taken bit
# u = unused, reserved for future
# p = size in words of previous allocation
# c = size in words of current allocation

# The maximum size of an allocation with this
# layout is (2^15)*4 = 131,072 bytes.

const taken_mask     := 0x00008000
const cur_size_mask  := 0x00007FFF
const prev_size_mask := 0x7FFF0000
const max_block_size := (1u32 bshl 15u32) * 4u32


# Initialize the heap by simply creating a single free node
# at the beginning of the heap, which is at __heap_start.

proc heap_init() {
    heap_sz := ptr_to_u32(&__heap_size)
    ptr     := ptrcast$u32(&__heap_start) # pointer to start of heap

    # Take 4 bytes from the size of the heap, that's this node
    # in the freelist.
    # Also divide by 4 since the size that we store is the
    # number of words.
    
    node : u32 = cur_size_mask band ((heap_sz - 4) bshr 2)

    @ptr = node

    write("Initializing heap at ")
    writehex(ptr_to_u32(ptr))
    write(", size: ")
    writehex(ptr_to_u32(&__heap_size))
    writeln()
}

# Returns either:
# 1. A pointer to a 4-byte-aligned region of memory at least as
#    large as you requested.
# 2. A NULL pointer, if the heap has no room.

proc kmalloc(size : u32) : u32* {
    # Check the size to make sure it's not too big or zero
    if size == 0
    or size > max_block_size {
        return HEAP_NULL
    }

    # Get size to be a multiple of 4,
    # then divide it by 4.
    rem := size band 0x3
    if rem != 0 {
        size += (4 - rem)
    }
    size = size bshr 2

    # Pointer to the start of our heap.
    start := &__heap_start
    # Used to offset the above pointer into the heap
    offset := 0u32
    # Pointer to the end of the heap
    end := &__heap_end
    node := 0u32
      
    # Loop until we find a free block that's big enough
    while true {
        addr := start + offset
        if addr >= end {
            # We've hit the end of the heap
            return HEAP_NULL
        }

        node      = @addr
        taken    := node band taken_mask
        cur_size := node band cur_size_mask

        if not taken and cur_size >= size {
            # We found a block that's:
            # 1. Not taken
            # 2. Large enough
            break
        }

        # Move on to the next node in the freelist.
        # Adding one to the offsets moves the "pointer" 4 bytes.
        offset += cur_size + 1
    }

    # The size of the block that we've chosen to take from, 
    # divided by 4 bytes
    blocksize := node band cur_size_mask
    prevsize  := node band prev_size_mask

    # If there will only be 4 bytes left, just give it away
    if blocksize == (size + 1) {
        size += 1
    }

    if blocksize > size {
        # Split the block that we've chosen to take from.
        # Only do this if we're not consuming the entire block.
        # Since this block is the block after the one that we're
        # currently allocating, its "previous size" will
        # be the size of the current allocation. 
        # It's size will be the size of the block minus what we're
        # about to take from it to do the current allocation.
        nextnode :=     ((blocksize - size - 1) band cur_size_mask)
                    bor ((size bshl 16) band prev_size_mask)
        start[offset + size + 1] = nextnode
    }

    # We write this into memory to do the allocation
    node =      taken_mask
            bor (size     band cur_size_mask)
            bor (prevsize band prev_size_mask)
    start[offset] = node

    # Return the pointer to the allocation
    return start + offset + 1
}

proc heap_print(max_offset : u32) {
    start  := &__heap_start
    offset := 0u32
    end    := &__heap_end

    # Print the whole heap
    writeln("===-===-===   HEAP   ===-===-===")
    while true {
        addr := start + offset
        if addr   >= end
        or offset >= max_offset {
            break
        }
        writebinln(@addr)
        offset += 1
    }
    writeln("===-===-=== END HEAP ===-===-===")
}

# Frees the pointer that you give it
proc kfree(arg_ptr : u32*) {
    ptr   := arg_ptr
    start := &__heap_start
    end   := &__heap_end

    # Sanity checks
    if ptr <  start
    or ptr >= end {
        write("kfree: Pointer was invalid: ")
        writehexln(ptr_to_u32(ptr))
    }

    # Grab the node in the freelist that's going to be freed.
    # Go ahead and free it by unsetting the "taken" bit.
    ptr   = ptr - 1
    node := @ptr
    node  = node band bneg taken_mask
    @ptr  = node

    # Save the information in the node
    size     := node band cur_size_mask
    prevsize := node band prev_size_mask

    # Look down to see if we need to merge the block below
    offset := size + 1
    if ptr + offset < end {
        nextnode := ptr[offset]
        if not (nextnode band taken_mask) {
            # If the next node isn't taken, merge.
            # Use the stored size since we're clearing it out in memory
            node = node band bneg cur_size_mask
            size = (nextnode band cur_size_mask) + size + 1
            node = node bor (size band cur_size_mask)
            @ptr = node
        }
    }

    # Look up to see if we need to merge the block above
    offset = prevsize + 1
    if prevsize != 0 {
        prevnode := ptr[0 - offset]

        write("Prevsize: ") writeln(prevsize)
        write("Offset:   ") writeln(offset)
        write("Offset:   ") writeln(0 - prevsize)
        write("Prevnode: ") writehexln(prevnode)

        if not (prevnode band taken_mask) {
            # If the previous node isn't taken, merge.
            prevnode = prevnode band bneg cur_size_mask
            prevnode =     prevnode
                       bor ((prevsize + size + 1) band cur_size_mask)
            ptr[0 - offset] = prevnode
        }
    }
}
