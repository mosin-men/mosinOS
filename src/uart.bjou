# uart.bjou
#
# UART driver code

module uart

using import "defs.bjou"

\static_if{ TARGET == QEMU
    const FREQ         := 65000000u32
    const ADDR         := (0x10013000u32 as void*) }
\static_if{ TARGET == E31
    const FREQ         := 32500000u32
    const ADDR         := (0x20000000u32 as void*) }
\static_if{ TARGET == HIFIVE
    const FREQ         := 17422745u32
    const ADDR         := (0x10013000u32 as void*) }

const BAUD_RATE    := 115200u32
const UART_DIVISOR := FREQ / BAUD_RATE - 1u32

# Offsets for UART registers. Actual addresses can be calculated by:
#   ADDR + (<register> * 4).
enum UartRegisters {
    TXDATA,
    RXDATA,
    TXCTRL,
    RXCTRL,
    IE,
    IP,
    DIV
}

#    Since this is a memory-mapped device, we can just have an empty struct
#    with some implementation functions for now and directly manipulate the
#    memory. In the future (when we have processes), we're going to need some
#    state so we can lock it out, but this will do for now.

#    Load the divisor into the UartRegisters.DIV register. This MUST be
#    called prior to attempting to read from/write to the UART.

proc configure() {
    mem := ADDR as u32*

    #    Enable both send and receive. Consider breaking this out into
    #    separate functions later, for finer control.
    #    Set bit 32 (1 << 31) and bit 31 (1 << 30)
    txreg := 0u32
    txreg = txreg bor (1u32 bshl 31u32)
    txreg = txreg bor (1u32 bshl 30u32)
    
    #    Set bit 32 (1 << 31)
    rxreg := 0u32
    rxreg = rxreg bor (1u32 bshl 31u32)

    #    Populate the memory for the divisor, the transmit control register,
    #    and the receive control register
    \volatile_w{ @(mem + (UartRegisters.DIV    as u32)) = UART_DIVISOR }
    \volatile_w{ @(mem + (UartRegisters.TXCTRL as u32)) = txreg        }
    \volatile_w{ @(mem + (UartRegisters.RXCTRL as u32)) = rxreg        }
}

proc read() : char {
    #    Read entire register into u32, if bit 31 is 0 return char, otherwise
    #    return false. DO NOT BLOCK
    mem := ADDR as u32*

    #    Read from the FIFO and see if data is available.
    val := \volatile_r{ @(mem + (UartRegisters.RXDATA as u32)) }

    #    Make sure we actually got something. If so, return it. Otherwise,
    #    return NOTHING
    if val band (1u32 bshl 31u32) {
        return 0 as char
    } else {
        return val as char
    }
}

proc read_echo() : char {
    c := read()
    if c == '\r'    write('\n')
    else            write(c)
    return c
}

proc write(out : char) {
    mem := ADDR as u32*
    
    # Check to ensure the FIFO isn't full and spin if it is.
    while true {
        fifo_full := \volatile_r{ @(mem + (UartRegisters.TXDATA as u32)) }
        if (fifo_full band (1u32 bshl 31u32)) == 0
            break
    }
    
    #    Since we're out of the above loop, we can write the char to data
    \volatile_w{ @(mem + (UartRegisters.TXDATA as u32)) = out as u32 }
}

proc write_string(s : char*) {
    while @s {
        write(@s)
        s += 1
    }
}
