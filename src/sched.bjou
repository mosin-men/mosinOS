# sched.bjou
#
# Completely Fair scheduler

module sched

using import "component_result.bjou"
using import "error.bjou"
using import "none.bjou"
using import "machine_info.bjou"
using import "heap.bjou"
using import "PCB.bjou"
using import "rbtree.bjou"
using import "util.bjou"
using import "mem.bjou"
using import "abort.bjou"

using import "console.bjou"

using import "brkpt.bjou"

sched : scheduler

proc init() : component_result {
    sched = scheduler.create()
    if not sched.init()
        return { error: .code = 1, .msg = "Failed to create process tree." }
    return { none: }
}

const NULL_PROC := NULL as PCB*

type proc_tree_t = rbtree$(u32, PCB*)

type scheduler {
    current   : PCB*
    proc_tree : proc_tree_t*
    next_pid  : i16
    qm_count  : u32

    proc create() : scheduler
        return { scheduler: }

    proc init(this) : bool {
        tree_ptr := kmalloc(sizeof proc_tree_t)
        if tree_ptr.is_null()
            return false
        this.proc_tree = tree_ptr as proc_tree_t*

        @this.proc_tree = proc_tree_t.create()

        timers := get_timers()
        reset_timers(timers.0, timers.1)
        return true
    }

    proc update_schedule(this, mepc : u32) : u32 {
        if this.current.is_null() {
            # there are no processes to schedule.. continue on 
            mepc_sav := mepc
            mepc      = this.schedule_next(mepc)
            return mepc
        }
        
        # writeln("update")
        
        mcopy(this.current.context, GLOBAL_CTX, (sizeof u32) * 32)        
        this.current.vruntime += this.current.QM
        this.current.pc        = mepc

        this.add_to_tree(this.current.vruntime, this.current)

        this.current = NULL as PCB*

        mepc = this.schedule_next(mepc)
        return mepc
    }

    proc schedule_next(this, mepc : u32) : u32 {
        waiting   := kmalloc(this.proc_tree.len * sizeof PCB*) as PCB**
        n_waiting := 0

        if waiting.is_null()    { abort("Could not allocate waiting list.") }

        all_pcbs  := this.collect_all_procs()

        while true {
            if p : (u32 ref, PCB* ref) = (@this.proc_tree).first() {
                vrt := unref(p.0)
                pcb := unref(p.1)

                (@this.proc_tree).remove(vrt)

                if not pcb.kill {
                    if pcb.sleep <= 0 { # not sleeping
                        if pcb.waitpid == -1 { # not waiting
                            this.current = pcb
                            break
                        } else {
                            if scheduler.array_of_pcbs_has_pid(all_pcbs, pcb.waitpid) { # waiting
                                waiting[n_waiting] = pcb
                                n_waiting += 1
                            } else { # schedule it
                                this.current         = pcb
                                this.current.waitpid = -1i16
                                break
                            }
                        }
                    } else { # sleeping
                        waiting[n_waiting] = pcb
                        n_waiting += 1
                    }
                } else { # kill the process
                    kfree(pcb.stack_pointer)
                    kfree(pcb)
                }
            } else { abort("scheduler did not find a viable process") }
        }

        for i := 0; i < n_waiting; i += 1 {
            this.add_to_tree(waiting[i].vruntime, waiting[i])
        }
        for ptr := all_pcbs; not (@ptr).is_null(); ptr += 1 {
            (@ptr).sleep -= 1
            # if (@ptr).sleep >= 0 {
            #     write((@ptr).name)  write("  ")  writeln((@ptr).sleep as i32)
            # }
        }

        mcopy(GLOBAL_CTX, this.current.context, (sizeof u32) * 32)        

        if not all_pcbs.is_null()
            kfree(all_pcbs)
        if not waiting.is_null()
            kfree(waiting)

        return this.current.pc
    }

    proc new_process(this, stack_size : u32, ip : u32, QM : u32, data : void*, data_len : u32, name : char*) : i32 {
        pcb      := kmalloc(sizeof PCB) as PCB*
        stack    := kmalloc(stack_size)

        if pcb.is_null() {
            abort("could not allocate process!")
        }
        if stack.is_null() {
            abort("could not allocate process stack!")
        }

        data_dst := NULL

        if data.is_null() {
            data_len = 0
            data_dst = stack + stack_size
        } else {
            data_dst = stack + stack_size - data_len
        }

        if (data_dst as u32) band 0x3 {
            data_dst = ((data_dst as u32) band bneg 0x3u32) as void*
        }

        mcopy(data_dst, data, data_len)

        pcb.context[10]   = data_dst as u32
        pcb.context[11]   = data_len
        pcb.context[2]    = data_dst as u32
        pcb.stack_pointer = stack as void*
        pcb.name          = name
        pcb.pid           = this.next_pid
        pcb.vruntime      = 0
        pcb.pc            = ip
        pcb.kill          = false
        pcb.QM            = QM
        pcb.waitpid       = -1i16
        pcb.sleep         = 0

        this.add_to_tree(pcb.vruntime, pcb)

        this.next_pid += 1

        return pcb.pid
    }

    proc add_to_tree(this, key : u32, val : PCB*) {
        while true {
            if n : none = (@this.proc_tree).lookup(key) {
                (@this.proc_tree).insert(key, val)
                break
            }
            key += 1
        }
    }

    proc _tree_get_node_with_pid(node : rbtree_node$(u32, PCB*)*, pid : i32) : rbtree_node$(u32, PCB*)* {
        if node.val.pid == pid { return node }

        if not node.children[0].is_null() {
            l := scheduler._tree_get_node_with_pid(node.children[0], pid)
            if not l.is_null()    { return l }
        }

        if not node.children[1].is_null() {
            r := scheduler._tree_get_node_with_pid(node.children[1], pid)
            if not r.is_null()    { return r }
        }

        return rbtree_node$(u32, PCB*).NULL_NODE
    }
    proc tree_has_pid(this, pid : i32) : bool {
        return not scheduler._tree_get_node_with_pid(this.proc_tree.root, pid).is_null()
    }
    proc get_pcb(this, pid : i32) : PCB* {
        if this.current.pid == pid {
            return this.current
        }

        node := scheduler._tree_get_node_with_pid(this.proc_tree.root, pid)

        if not node.is_null() {
            return node.val
        }

        return NULL as PCB*
    }
    proc _collect_all_procs(node : rbtree_node$(u32, PCB*)*, array : PCB**, idx : u32 ref) {
        array[idx] = node.val
        idx += 1

        if not node.children[0].is_null() {
            scheduler._collect_all_procs(node.children[0], array, idx) 
        }

        if not node.children[1].is_null() {
            scheduler._collect_all_procs(node.children[1], array, idx) 
        }
    }

    proc collect_all_procs(this) : PCB** {
        n := this.proc_tree.len + 1
        if not this.current.is_null()
            n += 1
        array := kmalloc(n * sizeof PCB*) as PCB**

        idx := 0u32
        if not this.current.is_null() {
            array[0] = this.current
            idx += 1
        }

        scheduler._collect_all_procs(this.proc_tree.root, array, idx)

        array[idx] = NULL as PCB*

        return array
    }

    proc array_of_pcbs_has_pid(array : PCB**, pid : i32) : bool {
        for ptr := array; not (@ptr).is_null(); ptr += 1 {
            if (@ptr).pid == pid
                return true
        }
        return false
    }
}

const QMS_PER_SEC := 100

proc get_timers() : (u32, u32) {
    mlo    := unref(get_clint_register(clint::MTIMELO))
    mhi    := unref(get_clint_register(clint::MTIMEHI))

    return (mlo, mhi)
}

proc reset_timers(prev_mlo : u32, prev_mhi : u32) {
    # writeln("----------------- reset_timers() -----------------")
    # write("prev_mlo:        ")  writehexln(prev_mlo as i32)
    # write("prev_mhi:        ")  writehexln(prev_mhi as i32)

    mcmplo := get_clint_register(clint::MTIMECMPLO)
    mcmphi := get_clint_register(clint::MTIMECMPHI)
    
    # write("mcmplo:          ")  writehexln(mcmplo as i32)
    # write("mcmphi:          ")  writehexln(mcmphi as i32)

    # write("FREQ:            ")  writeln(FREQ as i32)
    # write("QMS_PER_SEC      ")  writeln(QMS_PER_SEC)

    interval := (FREQ / 100) / QMS_PER_SEC

    # write("interval:        ")  writeln(interval)

    mtime64        := ((prev_mhi as u64) bshl 32) + (prev_mlo as u64)
    mtimecmp64     := mtime64 + interval
    new_mtimecmphi := (mtimecmp64 bshr 32) as u32
    new_mtimecmplo := (mtimecmp64 band 0x00000000FFFFFFFF) as u32

    # write("new_mtimecmplo:  ")  writehexln(new_mtimecmplo as i32)
    # write("new_mtimemcmphi: ")  writehexln(new_mtimecmphi as i32)

    mcmplo = new_mtimecmplo
    mcmphi = new_mtimecmphi
}
