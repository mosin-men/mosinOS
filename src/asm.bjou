# asm.bjou
#
# Provides general wrappers and bindings for functions defined 
# externally in assembly.
#
# asm() takes a template argument T which must have a member
# constant named 'routine'. 'routine' should evaluate to an extern
# binding to a function.
#
# asm() can take 0 to 8 arguments each of type u32.
# These arguments are passed in the RISC-V registers a0-a7
# A u32 is returned from argument a0.
#
# If an address needs to be passed to an assembly function,
# one should use ptr_to_u32() which is provided util.bjou as a 
# convenience to cast to u32.

module asm

# begin bindings and type wrappers
extern _wfi()
abstract type wfi { const routine := _wfi }
extern _ecall()
abstract type ecall { const routine := _ecall }
extern _enable_interrupts()
abstract type enable_interrupts { const routine := _enable_interrupts }
extern _semaphore_inc()
abstract type semaphore_inc { const routine := _semaphore_inc }
extern _semaphore_dec()
abstract type semaphore_dec { const routine := _semaphore_dec }
extern _fence()
abstract type fence { const routine := _fence }
extern _umode_switch()
abstract type umode_switch { const routine := _umode_switch }
extern _mmode_switch()
abstract type mmode_switch { const routine := _mmode_switch }
# end bindings and type wrappers

proc asm$T() : u32 {
    v_fn := T.routine as void*
    fn   := (v_fn as <() : u32>)
    return fn()
}

proc asm$T(a0 : u32) : u32 {
    v_fn := T.routine as void*
    fn   := (v_fn as <(u32) : u32>)
    return fn(a0)
}

proc asm$T(a0 : u32, a1 : u32) : u32 {
    v_fn := T.routine as void*
    fn   := (v_fn as <(u32, u32) : u32>)
    return fn(a0, a1)
}

proc asm$T(a0 : u32, a1 : u32, a2 : u32) : u32 {
    v_fn := T.routine as void*
    fn   := (v_fn as <(u32, u32, u32) : u32>)
    return fn(a0, a1, a2)
}

proc asm$T(a0 : u32, a1 : u32, a2 : u32, a3 : u32) : u32 {
    v_fn := T.routine as void*
    fn   := (v_fn as <(u32, u32, u32, u32) : u32>)
    return fn(a0, a1, a2, a3)
}

proc asm$T(a0 : u32, a1 : u32, a2 : u32, a3 : u32,
                a4 : u32) : u32 {
    v_fn := T.routine as void*
    fn   := (v_fn as <(u32, u32, u32, u32, u32) : u32>)
    return fn(a0, a1, a2, a3, a4)
}

proc asm$T(a0 : u32, a1 : u32, a2 : u32, a3 : u32,
                a4 : u32, a5 : u32) : u32 {
    v_fn := T.routine as void*
    fn   := (v_fn as <(u32, u32, u32, u32, u32, u32) : u32>)
    return fn(a0, a1, a2, a3, a4, a5)
}

proc asm$T(a0 : u32, a1 : u32, a2 : u32, a3 : u32,
                a4 : u32, a5 : u32, a6 : u32) : u32 {
    v_fn := T.routine as void*
    fn   := (v_fn as <(u32, u32, u32, u32, u32, u32, u32) : u32>)
    return fn(a0, a1, a2, a3, a4, a5, a6)
}

proc asm$T(a0 : u32, a1 : u32, a2 : u32, a3 : u32,
                a4 : u32, a5 : u32, a6 : u32, a7 : u32) : u32 {
    v_fn := T.routine as void*
    fn   := (v_fn as <(u32, u32, u32, u32, u32, u32, u32, u32) : u32>)
    return fn(a0, a1, a2, a3, a4, a5, a6, a7)
}
