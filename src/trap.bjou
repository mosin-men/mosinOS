# trap.bjou

module trap

using import "console.bjou"
using import "clint.bjou"
using import "defs.bjou"
using import "machine_info.bjou"
using import "util.bjou"
using import "pcb.bjou"

const INTERRUPT_MASK := 0x80000000u32
const CODE_MASK      := 0x7FFFFFFFu32
const INST_MASK      := 0x00000003u32

# asynchronous traps
const USOFTWARE := 0u32 # User software interrupt
const SSOFTWARE := 1u32 # Supervisor software interrupt
const MSOFTWARE := 3u32 # Machine software interrupt
const UTIME     := 4u32 # User timer interrupt
const STIME     := 5u32 # Supervisor timer interrupt
const MTIME     := 7u32 # Machine timer interrupt
const UEXT      := 8u32 # User external interrupt
const SEXT      := 9u32 # Supervisor external interrupt
const MEXT      := 11u32 # Machine external interrupt

# synchronous traps
const IADDMISS  := 0u32  # Instruction address misaligned
const IACCESS   := 1u32  # Instruction access fault
const ILLINST   := 2u32  # Illegal instruction
const BREAKPT   := 3u32  # Breakpoint
const LDADDMISS := 4u32  # Load address misaligned
const LDACCESS  := 5u32  # Load access fault
const STADDMISS := 6u32  # Store/AMO address misaligned
const STACCESS  := 7u32  # Store/AMO access fault
const UECALL    := 8u32  # Environment call from U-mode
const SECALL    := 9u32  # Environment call from S-mode
const MECALL    := 11u32 # Environment call from M-mode
const IPGFAULT  := 12u32 # Instruction page fault
const LDPGFAULT := 13u32 # Load page fault
const STPGFAULT := 15u32 # Store/AMO page fault

proc __no_mangle__ trap_handler(cause : u32, mepc : u32) : u32 {
    writeln("In trap handler")
    write("cause: ") writehexln(cause)
    write("mepc:  ") writehexln(mepc)

    interrupt := cause band INTERRUPT_MASK
    code      := cause band CODE_MASK

    if interrupt == INTERRUPT_MASK {
        async_handler(code)
        return mepc
    } else if interrupt == 0 {
        sync_handler(code)
        return update_mepc(mepc)
    } else {
        write("Unknown trap cause: ") writeln(cause)
    }

    return 0
}

proc async_handler(code : u32) {
    if code == USOFTWARE  {
        writeln("USOFTWARE")
    } else if code == SSOFTWARE  {
        writeln("SSOFTWARE")
    } else if code == MSOFTWARE  {
        writeln("MSOFTWARE")
    } else if code == UTIME      {
        writeln("UTIME")
    } else if code == STIME      {
        writeln("STIME")
    } else if code == MTIME      {
        writeln("MTIME")
        reset_timers()
    } else if code == UEXT       {
        writeln("UEXT")
    } else if code == SEXT       {
        writeln("SEXT")
    } else if code == MEXT       {
        writeln("MEXT")
    } else {
        writeln("Unknown asynchronous trap code")
    }
}

proc sync_handler(code : u32) {
    if code == IADDMISS   {
        writeln("IADDMISS")
    } else if code == IACCESS    {
        writeln("IACCESS")
    } else if code == ILLINST    {
        writeln("ILLINST")
    } else if code == BREAKPT    {
        writeln("BREAKPT")
    } else if code == LDADDMISS  {
        writeln("LDADDMISS")
    } else if code == LDACCESS   {
        writeln("LDACCESS")
    } else if code == STADDMISS  {
        writeln("STADDMISS")
    } else if code == STACCESS   {
        writeln("STACCESS")
    } else if code == UECALL     {
        writeln("UECALL")
    } else if code == SECALL     {
        writeln("SECALL")
    } else if code == MECALL     {
        writeln("MECALL")
    } else if code == IPGFAULT   {
        writeln("IPGFAULT")
    } else if code == LDPGFAULT  {
        writeln("LDPGFAULT")
    } else if code == STPGFAULT  {
        writeln("STPGFAULT")
    } else {
        writeln("Unknown synchronous trap code")
    }
}

proc update_mepc(mepc : u32) : u32 {
    instruction := @u32toptr$u32(mepc)
    if (instruction band INST_MASK) == INST_MASK
        return mepc + 4
    return mepc + 2
}

proc reset_timers() {
    mlo    := get_clint_register(clint::MTIMELO)
    mhi    := get_clint_register(clint::MTIMEHI)
    mcmplo := get_clint_register(clint::MTIMECMPLO)
    mcmphi := get_clint_register(clint::MTIMECMPHI)

    cur_mlo : u32 = mlo
    cur_mhi : u32 = mhi

    interval := FREQ

    mtime64 := ((cur_mhi as u64) bshl 32) + (cur_mlo as u64)
    mtimecmp64 := mtime64 + interval
    new_mtimecmphi := (mtimecmp64 bshr 32) as u32
    new_mtimecmplo := (mtimecmp64 band 0x00000000FFFFFFFF) as u32

    mcmplo = new_mtimecmplo
    mcmphi = new_mtimecmphi
}
