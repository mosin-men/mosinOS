# trap.bjou

module trap

using import "console.bjou"
using import "ansi_escapes.bjou"
using import "clint.bjou"
using import "defs.bjou"
using import "machine_info.bjou"
using import "util.bjou"
using import "sched.bjou"
using import "PCB.bjou"
using import "syscall.bjou"
using import "abort.bjou"

status_bar_counter : u32

const INTERRUPT_MASK := 0x80000000u32
const ASYNC          := INTERRUPT_MASK
const CODE_MASK      := 0x7FFFFFFFu32
const INST_MASK      := 0x00000003u32

# asynchronous traps
const USOFTWARE := 0u32 # User software interrupt
const SSOFTWARE := 1u32 # Supervisor software interrupt
const MSOFTWARE := 3u32 # Machine software interrupt
const UTIME     := 4u32 # User timer interrupt
const STIME     := 5u32 # Supervisor timer interrupt
const MTIME     := 7u32 # Machine timer interrupt
const UEXT      := 8u32 # User external interrupt
const SEXT      := 9u32 # Supervisor external interrupt
const MEXT      := 11u32 # Machine external interrupt

# synchronous traps
const IADDMISS  := 0u32  # Instruction address misaligned
const IACCESS   := 1u32  # Instruction access fault
const ILLINST   := 2u32  # Illegal instruction
const BREAKPT   := 3u32  # Breakpoint
const LDADDMISS := 4u32  # Load address misaligned
const LDACCESS  := 5u32  # Load access fault
const STADDMISS := 6u32  # Store/AMO address misaligned
const STACCESS  := 7u32  # Store/AMO access fault
const UECALL    := 8u32  # Environment call from U-mode
const SECALL    := 9u32  # Environment call from S-mode
const MECALL    := 11u32 # Environment call from M-mode
const IPGFAULT  := 12u32 # Instruction page fault
const LDPGFAULT := 13u32 # Load page fault
const STPGFAULT := 15u32 # Store/AMO page fault

proc __no_mangle__ trap_handler(cause : u32, mepc : u32, mtval : u32) : u32 {
    # writeln("In trap handler")
    # write("cause: ") writehexln(cause)
    # write("mepc:  ") writehexln(mepc)
    # write("mtval: ") writehexln(mtval)

    mode := cause band INTERRUPT_MASK
    code := cause band CODE_MASK

    if mode == ASYNC {
        mepc = async_handler(code, mepc, mtval)
    } else if mode == 0 {
        mepc = sync_handler(code, mepc, mtval)
    } else {
        write("Unknown trap cause: ") writeln(cause as i32)
    }

    mepc = update_mepc(mepc, mode)

    # write("trap_handler: new mepc = ")  writehexln(mepc)
    return mepc
}

proc async_handler(code : u32, mepc : u32, mtval : u32) : u32 {
    if code == USOFTWARE  {
        writeln("USOFTWARE")
    } else if code == SSOFTWARE  {
        writeln("SSOFTWARE")
    } else if code == MSOFTWARE  {
        writeln("MSOFTWARE")
    } else if code == UTIME      {
        writeln("UTIME")
    } else if code == STIME      {
        writeln("STIME")
    } else if code == MTIME      {
        # writeln("MTIME")
        timers := sched::get_timers()
        mepc    = sched.update_schedule(mepc)
        sched::reset_timers(timers.0, timers.1)

        if status_bar_counter == sched::QMS_PER_SEC / 10 {
            draw_status()
            status_bar_counter = 0
        } else {
            status_bar_counter += 1
        }
    } else if code == UEXT       {
        writeln("UEXT")
    } else if code == SEXT       {
        writeln("SEXT")
    } else if code == MEXT       {
        writeln("MEXT")
    } else {
        writeln("Unknown asynchronous trap code")
    }

    return mepc
}

proc sync_handler(code : u32, mepc : u32, mtval : u32) : u32 {
    if code == IADDMISS   {
        abort("IADDMISS", mtval)
    } else if code == IACCESS    {
        abort("IACCESS", mtval)
    } else if code == ILLINST    {
        abort("Instruction access fault!", mtval)
    } else if code == BREAKPT    {
        writeln("BREAKPT")
    } else if code == LDADDMISS  {
        abort("LDADDMISS")
    } else if code == LDACCESS   {
        abort("LDACCESS", mtval)
    } else if code == STADDMISS  {
        abort("STADDMISS", mtval)
    } else if code == STACCESS   {
        abort("STACCESS", mtval)
    } else if code == UECALL     {
        writeln("UECALL")
        write("Got syscall number ")
        writeln(GLOBAL_CTX[10] as i32)
    } else if code == SECALL     {
        writeln("SECALL")
    } else if code == MECALL     {
        result := handle_syscall(
            GLOBAL_CTX[10],
            GLOBAL_CTX[11],
            GLOBAL_CTX[12],
            GLOBAL_CTX[13],
            GLOBAL_CTX[14],
            GLOBAL_CTX[15],
            GLOBAL_CTX[16])
        GLOBAL_CTX[10] = result
    } else if code == IPGFAULT   {
        writeln("IPGFAULT")
    } else if code == LDPGFAULT  {
        writeln("LDPGFAULT")
    } else if code == STPGFAULT  {
        writeln("STPGFAULT")
    } else {
        abort("Unknown synchronous trap code")
    }

    return mepc
}

proc update_mepc(mepc : u32, mode : u32) : u32 {
    if mode == ASYNC
        return mepc

    instruction := @u32_to_ptr$u32(mepc)

    if (instruction band INST_MASK) == INST_MASK
        return mepc + 4

    return mepc + 2
}

proc draw_status() {
    write(CURSOR_SAVE)
    write(CURSOR_HOME)
    write(CLEAR_LINE)
    write(RESET)
    write(UNDERLINE)
    write("|    ")
    write(BOLD)
    write("MosinOS")
    write(BOLD_OFF) 
    write("    | current: ")

    if sched.current.is_null()
        writepad("???", 16)
    else
        writepad(sched.current.name, 16)

    write(" | heap used: ")
    write(__heap_used as i32)  write(" / ")  write(ptr_to_u32(&__heap_size) as i32)
    write(" |")
    write(RESET)
    write(CURSOR_RESTORE)
}

