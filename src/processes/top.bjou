# top.bjou

module process_top

using import "syscall.bjou"
using import "cstr.bjou"
using import "util.bjou"
using import "sched.bjou"
using import "PCB.bjou"

type top {
    const STACK_SIZE := 512
    const QM         := 1
    const PROC_NAME  := "top"

    proc routine(data : void*, data_len : u32) {
        array := NULL as process_info*
        n     := syscall::procs(&array)
        ptr   := array

        if data_len >= 2 {
            pid := atoi(data as char*) 
            found := false
            for i := 0; i < n; i += 1 {
                if array[i].pid == pid {
                    print_header()
                    print_proc_info(array[i].pid, array[i].vruntime, array[i].name, array[i].waitpid, array[i].sleep)
                    found = true
                    break
                }
            }
            if not found    { write("top: pid ")  write(pid)  writeln(" not found.") }
        } else {
            print_header()
            for i := 0; i < n; i += 1
                print_proc_info(array[i].pid, array[i].vruntime, array[i].name, array[i].waitpid, array[i].sleep)
        }

        if not array.is_null()
            syscall::free(array)
    }
}

proc print_header() {
    writeln("PID    STATUS     VRUNTIME(QM)    TIME(s)    CMD")
}

proc print_proc_info(pid : i32, vruntime : u32, name : char*, waitpid : i16, sleep : i16) {
    status_strs := { "running", "waiting", "sleeping" }

    status := 0
    if waitpid != -1i16
        status = 1
    if sleep > 0
        status = 2
    

    buff : char[32]
    itoa(pid, buff)
    writepad(buff, 3)  write("    ")
    writepad(status_strs[status], 8)  write("   ")
    itoa(vruntime, buff)
    writepad(buff, 12)  write("    ")
    itoa(vruntime / sched::QMS_PER_SEC, buff)

    if pid == syscall::mypid() {
        writepad(buff, 7)  write("   *")
    } else {
        writepad(buff, 7)  write("    ")
    }
    writeln(name)
}
